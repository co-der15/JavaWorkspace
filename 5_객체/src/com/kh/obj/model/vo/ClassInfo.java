package com.kh.obj.model.vo;

public class ClassInfo {

	/* 클래스 작성 방법
	 * [접근 제한자] [예약어] class 클래스명 {
	 * 	** 클래스명 : 앞글자는 대문자, 클래스 이름은
	 *              .java의 파일명과 동일해야 한다.
	 * }
	 * public   final(종단, 끝), abstract(미완성된)
	 * default(만약 접근제한자가 생략되었을 경우)
	 * 
	 * - 사용 예시 -
	 *  class 클래스명{ ... } : default 클래스
	 *   - 같은 패키지 안에 있는 클래스들 끼리만
	 *     import 없이 사용이 가능한 클래스
	 *  public class 클래스명{} : 대표 클래스 
	 *   - 한 파일의 대표를 뜻하는 클래스
	 *   - 한 파일 내에 단 한 개만 존재하는 클래스
	 *   - public : 같은 패키지 내에서는 import없이
	 *              사용이 가능하고, 다른 패키지에서는
	 *              import 선언을 하여 사용할 수 있다.
	 *  public final class 클래스명{} : 종단 클래스
	 *   - 이 클래스가 끝이다!
	 *   - 상속을 하지 못하게 막는 클래스를 뜻한다.
	 *   - 클래스의 기능 확장을 막기 위해 사용한다.
	 *  public abstract class 클래스명{} : 추상 클래스
	 *   - 미완성된 클래스를 의미
	 *   - 반드시 상속을 통해서 구현해야 하는 부모 클래스를 뜻함
	 *   - 직접 객체 생성은 하지 못하며 자식 객체를 통해서만
	 *     사용할 수 있다.
	 */
		
	// 1. 필드 변수(Field)
	/*
	* [접근제한자] [예약어] 자료형 변수명 [= 초기값];
	* - private   final, static, final static(static final), varient 
	* ~ default   (수정X) (정적메모리에 값 기입 / 공유용도)
	* # protected 
	* + public 
	* 
	* ---------------
	* 접근 제한자 : 다른 영역에서의 현재 변수 접근을 제한하는 예약어
	* (-) private : 
	*     현재 클래스 안에서만 접근이 가능한 제한자
	* 	   (캡슐화의 원칙, 기본 사항)
	* (~) default : 
	*     같은 패키지 내에서만 접근이 가능한 제한자
	*     다른 패키지에서는 접근이 불가능
	* (#) protected : 
	*     같은 패키지 내에서는 그냥 접근이 가능하고
	*     다른 패키지일 경우에는 현재 클래스를 상속받은
	*     자식만 접근할 수 있는 제한자
	* (+) public :
	*     안과 밖 모든 패키지에서 접근이 가능한 공용 제한자
	*     단, 다른 패키지에서 접근할 경우 import를 선언해야 한다.
	*/
	
	// 2. 생성자
	/*
	* 다른 패키지나 사용하고자 하는 클래스에서 현재 클래스를
	* 통한 객체를 생성할 때 사용하는 메소드
	* 
	* [접근제한자] 클래스명([매개변수]){ ... }
	* - 기본 원칙은 public이다.
	*  - 다른 클래스에서 생성하려는 목적으로 만들었기 때문
	* 
	* 생성하지 않았을 경우에는 기본적으로 default 생성자가
	* 만들어지지만, 상속 관계에 있는 클래스의 경우에는
	* 기본생성자가 자동으로 만들어지지 않는다.
	* - 생성자는 기본 생성자와 사용하기 위한 생성자를
	*   직접 작성하는 것이 원칙이다.
	* 
	* - protected, private 접근제한자도 가능하나,
	*   이 경우에는 Singleton-Design Pattern 구현 시에
	*   사용하고 일반적으로는 public으로 선언한다.
	*   
	*   기본 생성자
	*    public 클래스명(){ . . . }
	*    
	*   사용자 정의 생성자
	*    public 클래스명(매개변수){
	*    	 [this.]필드변수명 = 매개변수명;
	*    }
	*    
	*    this 레퍼런스 :
	*    	생성자와 메소드 안에 무조건 존재하는 객체 자신을
	*      가리키는 레퍼런스 변수명;
	*      클래스내의 특정 메소드를 실행할 때, 현재 실행되는
	*      객체 자신의 주소값을 가져온다.
	*      일반적으로 하나의 구역 {} 이내에 같은 이름의 
	*      지역변수가 존재하지 않을 경우 컴파일러가 구동 시
	*      필드변수명 앞에 자동으로 this.을 추가한다.
	*/
	
	// 3. 기능 제공 메소드
	/*
	* [접근제한자] [예약어] 반환자료형 메소드명([매개변수, ..]){ ... }
	*  public    final, static, static final, abstract
	*  - final : 상속을 받은 자식 객체가 부모의 메소드 내용을 
	*            바꾸지 못하게(재정의:Overriding) 막는 예약어
	*  - static : 정적메모리에 메소드를 기록하여 공유용도로
	*             사용하기 위한 예약어
	*    사용형식은 클래스명.메소드명(); 으로 직접 접근이 가능하다.
	*  - abstract : 미완성된 메소드
	*               현재 클래스는 사용하지 못하지만,
	*               자식 클래스를 통해 재정의(Overriding)하여
	*               사용하도록 정의된 메소드
	*    선언형식은 [접근제한자] [예약어] 반환자료형 메소드명([매개변수]);
	*      - { 구현 부 } 가 없다.
	* 
	*  - 접근제한자는 field에서 사용하는 접근 제한자와 동일하다.
	* 
	*  ** Getter & Setter **
	*  기능 제공 메소드 중
	*  private으로 접근이 불가능한 field에 대해서
	*  간접적으로나마 접근을 시켜주는 메소드
	*  
	*  -- 현재 필드의 값을 가져오는 메소드
	*  public 반환자료형 get변수명(앞글자를 대문자)(){
	*  	return 변수명;
	*  }
	*  
	*  -- 현재 필드의 값을 매개변수로 받은 값으로
	*     변경하는 메소드
	*  public void set변수명(매개변수){
	*  	this.변수명 = 매개변수명;
	*  }
	*  
	*  ** 반환자료형 / return;
	*  해당 메소드가 종료되면서 돌려줄 결과 값을
	*  의미하는 선언부
	*  
	*  public String test1(){
	*  	return "test";
	*  }
	*  
	*  public void test2(){
	*  	return;
	*      // 작성하지 않았을 경우
	*      // 컴파일러에 의해서 자동으로 추가된다.
	*  }
	*/
}